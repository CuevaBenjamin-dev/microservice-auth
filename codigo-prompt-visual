login.ts (front) :


import { provideHttpClient } from '@angular/common/http';
import { Component } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { FormBuilder, FormGroup } from '@angular/forms';
import { AuthService } from '../../services/auth-service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [ReactiveFormsModule],
  templateUrl: './login.html',
  styleUrl: './login.css',
})
export class LoginComponent {
  form: FormGroup;

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
  ) {
    this.form = this.fb.group({
      usuario: [''],
      password: [''],
    });
  }

  onSubmit(): void {
    const request = {
      usuario: this.form.value.usuario,
      password: this.form.value.password,
    };

    this.authService.login(request).subscribe({
      next: (res) => {
        if (res.success && res.data) {
          localStorage.setItem('accessToken', res.data.accessToken);
          localStorage.setItem('refreshToken', res.data.refreshToken);
          alert('Login exitoso');
        }
      },
      error: (err) => {
        alert(err.error.message);
      },
    });
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

interfaces.ts (front) :


/**
 * Contrato base de respuesta del backend.
 * Debe coincidir con ApiResponse<T> (backend).
 */
export interface ApiResponse<T> {
  success: boolean;
  message: string;
  data: T | null;
  errors: any | null;
}

/**
 * Contrato de solicitud de login.
 */
export interface LoginRequest {
  usuario: string;
  password: string;
}

/**
 * Tokens de autenticación.
 * Debe coincidir con AuthTokensResponse (backend).
 */
export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

auth-service.ts (front) :


import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { LoginRequest, ApiResponse, AuthTokens } from '../models/interfaces';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private apiUrl = 'http://localhost:8080/auth/login';

  constructor(private http: HttpClient) {}

  /**
   * Login del usuario.
   *
   * NIVEL 4:
   * - Devuelve accessToken y refreshToken
   */
  login(request: LoginRequest): Observable<ApiResponse<AuthTokens>> {
    return this.http.post<ApiResponse<AuthTokens>>(this.apiUrl, request);
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AuthController.java (back) :


package com.service.microservice_auth.controllers;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.service.microservice_auth.dtos.ApiResponse;
import com.service.microservice_auth.dtos.AuthTokensResponse;
import com.service.microservice_auth.dtos.LoginRequest;
import com.service.microservice_auth.security.JwtService;
import com.service.microservice_auth.services.UsuarioService;

import jakarta.validation.Valid;

/**
 * Controlador de autenticación.
 * 
 * NIVEL 2:
 * - Usa DTOs explícitos
 * - Usa ApiResponse como formato estándar
 * - NO aplica hashing ni tokens todavía
 */
@CrossOrigin(origins = "*") // en producción se restringirá
@RestController
@RequestMapping("/auth")
public class AuthController {

    private final JwtService jwtService;
    private final UsuarioService usuarioService;

    public AuthController(JwtService jwtService, UsuarioService usuarioService) {
        this.jwtService = jwtService;
        this.usuarioService = usuarioService;
    }

    /**
     * Endpoint de login básico.
     * 
     * Flujo:
     * 1. Recibe credenciales (LoginRequest)
     * 2. Valida datos (@Valid)
     * 3. Llama a UsuarioService
     * 4. Devuelve ApiResponse estándar
     */
    @PostMapping("/login")
    public ResponseEntity<ApiResponse<?>> login(@Valid @RequestBody LoginRequest request) {

        boolean success = usuarioService.login(
                request.getUsuario(),
                request.getPassword());

        if (!success) {
            return ResponseEntity.status(401).body(
                    ApiResponse.error("Usuario o contraseña incorrectos", null));
        }

        // Generar tokens
        String accessToken = jwtService.generateAccessToken(request.getUsuario());
        String refreshToken = jwtService.generateRefreshToken(request.getUsuario());

        AuthTokensResponse tokens = new AuthTokensResponse(
                accessToken,
                refreshToken);

        return ResponseEntity.ok(
                ApiResponse.ok("Login exitoso", tokens));
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7


Usuario.java :


package com.service.microservice_auth.models;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Entity
@Table(name = "usuarios")
public class Usuario {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 15)
    private String usuario;

    @Column(nullable = false, length = 50)
    private String password;
    
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7

UsuarioRepository.java (back) :

package com.service.microservice_auth.repositories;

import org.springframework.data.jpa.repository.JpaRepository;

import com.service.microservice_auth.models.Usuario;
import java.util.Optional;


public interface UsuarioRepository extends JpaRepository<Usuario, Long> {

    Optional<Usuario> findByUsuario(String usuario);

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7

UsuarioService.java (back) :


package com.service.microservice_auth.services;

import java.util.Optional;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import com.service.microservice_auth.models.Usuario;
import com.service.microservice_auth.repositories.UsuarioRepository;

/**
 * Servicio de dominio para usuarios.
 * 
 * NIVEL 3:
 * - Comparación segura de contraseñas con BCrypt
 * - Nunca compara texto plano con texto plano
 */
@Service
public class UsuarioService {

    private final UsuarioRepository usuarioRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    public UsuarioService(
            UsuarioRepository usuarioRepository,
            BCryptPasswordEncoder passwordEncoder) {

        this.usuarioRepository = usuarioRepository;
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * Valida credenciales del usuario.
     *
     * @param usuario  username ingresado
     * @param password contraseña en texto plano (input)
     * @return true si las credenciales son válidas
     */
    public boolean login(String usuario, String password) {

        Optional<Usuario> usuarioDB = usuarioRepository.findByUsuario(usuario);

        if (usuarioDB.isEmpty()) { // significa que si usuarioDB no tiene un valor dentro entonces return false
            return false;
        }

        // return usuarioDB.get().getPassword().equals(password);
        // BCrypt compara texto plano vs hash almacenado
        return passwordEncoder.matches( // qué hace matches? compara el texto plano con el hash almacenado
                password, 
                usuarioDB.get().getPassword());
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LoginRequest.ts (back) :


package com.service.microservice_auth.dtos;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * DTO que representa la solicitud de login.
 * NIVEL 2:
 * - Validación declarativa (fail fast)
 * - Aún NO aplica hashing ni tokens
 */
public class LoginRequest {

    @NotBlank(message = "El campo 'usuario' no puede estar vacío")
    @Size(min = 5, max = 15, message = "El campo 'usuario' debe tener entre 5 y 15 caracteres")
    private String usuario;

    @NotBlank(message = "El campo 'password' no puede estar vacío")
    @Size(min = 8, max = 50, message = "El campo 'password' debe tener entre 8 y 50 caracteres")
    private String password;

    public String getUsuario() {
        return usuario;
    }

    public void setUsuario(String usuario) {
        this.usuario = usuario;
    }

    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LoginResponse.ts (back) :


package com.service.microservice_auth.dtos;

/**
 * DTO de respuesta estándar para el login.
 * 
 * En niveles posteriores este DTO podrá extenderse
 * (token, roles, expiración, etc) sin romper el frontend.
 */
public class LoginResponse {

    private boolean success;
    private String message;

    public LoginResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GlobalExceptionHandler.java (back) :


package com.service.microservice_auth.handlers;

import java.util.HashMap;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.service.microservice_auth.dtos.ApiResponse;

/**
 * Manejador global de excepciones.
 * 
 * NIVEL 2:
 * - Centraliza errores
 * - Devuelve ApiResponse estándar
 * - Evita lógica de errores en los controllers
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Maneja errores de validación (@Valid).
     * 
     * Se ejecuta automáticamente cuando un DTO
     * no cumple las reglas declaradas.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<?>> handleValidation(MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();

        for (FieldError err : ex.getBindingResult().getFieldErrors()) {
            errors.put(err.getField(), err.getDefaultMessage());
        }

        return ResponseEntity.badRequest().body(
            ApiResponse.error("Datos inválidos", errors)
        );
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ApiResponse.java (back) :


package com.service.microservice_auth.dtos;

/**
 * Respuesta estándar del API.
 * 
 * NIVEL 2 - PASO 3:
 * - Unifica TODAS las respuestas del backend
 * - Facilita escalabilidad y reutilización
 */
public class ApiResponse<T> {

    private boolean success;
    private String message;
    private T data;
    private Object errors;

    public ApiResponse(boolean success, String message, T data, Object errors) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.errors = errors;
    }

    public boolean isSuccess() { return success; }
    public String getMessage() { return message; }
    public T getData() { return data; }
    public Object getErrors() { return errors; }

    // Helpers estáticos (muy útiles)
    public static <T> ApiResponse<T> ok(String message, T data) {
        return new ApiResponse<>(true, message, data, null);
    }

    public static ApiResponse<?> error(String message, Object errors) {
        return new ApiResponse<>(false, message, null, errors);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SecurityConfig.java (back) :


package com.service.microservice_auth.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * Configuración de seguridad básica.
 * 
 * NIVEL 3:
 * - Provee BCryptPasswordEncoder como Bean
 * - Aún NO usa Spring Security (filtros, JWT, etc)
 */
@Configuration
public class SecurityConfig {

    /**
     * BCrypt con fuerza por defecto (10).
     * 
     * Suficiente para la mayoría de sistemas.
     */
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

JwtService.java (back) :


package com.service.microservice_auth.security;

import java.util.Date;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;

import javax.crypto.SecretKey;

/**
 * Servicio encargado de generar y gestionar JWT.
 * 
 * NIVEL 4:
 * - Access Token (vida corta)
 * - Refresh Token (vida larga)
 */
@Service
public class JwtService {

    private final SecretKey secretKey;
    private final long accessExpirationMs;
    private final long refreshExpirationMs;

    public JwtService(
            @Value("${jwt.secret}") String secret,
            @Value("${jwt.access-expiration-ms}") long accessExpirationMs,
            @Value("${jwt.refresh-expiration-ms}") long refreshExpirationMs) {

        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes());
        this.accessExpirationMs = accessExpirationMs;
        this.refreshExpirationMs = refreshExpirationMs;
    }

    /**
     * Genera un ACCESS TOKEN.
     * 
     * - Se usa para acceder a endpoints protegidos
     * - Vida corta
     */
    public String generateAccessToken(String username) {
        return generateToken(username, accessExpirationMs, "ACCESS");
    }

    /**
     * Genera un REFRESH TOKEN.
     * 
     * - Se usa solo para renovar el access token
     * - Vida larga
     */
    public String generateRefreshToken(String username) {
        return generateToken(username, refreshExpirationMs, "REFRESH");
    }

    /**
     * Método interno para generar tokens JWT.
     */
    private String generateToken(String username, long expirationMs, String type) {

        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setSubject(username)          // Usuario autenticado
                .claim("type", type)           // ACCESS o REFRESH
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AuthTokensResponse.java (back) :


package com.service.microservice_auth.dtos;

/**
 * DTO que representa los tokens de autenticación.
 * 
 * NIVEL 4:
 * - accessToken: se usa para acceder a recursos
 * - refreshToken: se usa para renovar el access token
 */
public class AuthTokensResponse {

    private String accessToken;
    private String refreshToken;

    public AuthTokensResponse(String accessToken, String refreshToken) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public String getRefreshToken() {
        return refreshToken;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

application.properties (back) :


spring.application.name=microservice-auth

# ===============================
# CONFIGURACIÓN DEL SERVIDOR
# ===============================
server.port=8080

# ===============================
# DATASOURCE - MYSQL
# ===============================
spring.datasource.url=jdbc:mysql://localhost:3306/ipde
spring.datasource.username=root
spring.datasource.password=wa1000201002
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ===============================
# JPA / HIBERNATE
# ===============================
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Dialecto recomendado para MySQL
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect

# Deshabilitar Open Session in View para evitar problemas de LazyInitializationException
spring.jpa.open-in-view=false

# ===============================
# JWT CONFIGURATION
# ===============================

# Clave para firmar tokens
jwt.secret=mi_clave_secreta_super_segura_2026

# Access token: 15 minutos
jwt.access-expiration-ms=900000

# Refresh token: 7 días
jwt.refresh-expiration-ms=604800000

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7

base de datos - ipde :


CREATE DATABASE ipde; 
USE ipde;

CREATE TABLE usuarios (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    usuario VARCHAR(15) NOT NULL,
    password VARCHAR(50) NOT NULL
);

INSERT INTO usuarios (usuario, password)
VALUES ('admin', '12345');

UPDATE USUARIOS
SET PASSWORD = '12345678' 
WHERE ID = 1;

------------------------------------------------------
-- segundo cambio por integración de BCRYPT en back --
------------------------------------------------------

ALTER TABLE usuarios
MODIFY password VARCHAR(255) NOT NULL;

UPDATE usuarios 
SET PASSWORD = '$2a$12$eh.IQT6XJSYFCQUz9oG2QuUZ3ywHKSojcwVRPQg6QkjKh2mY6oh2C'
WHERE ID = 1;

------------------------------------------------------

------------------------------------------------------


SELECT * FROM usuarios;
